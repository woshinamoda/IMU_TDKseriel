/*
$License:
Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
$
*/

/* WARNING: autogenerated code, do not modify */
/**
*  @defgroup DMPDEFAULT
*  @brief
*
*  @{
*      @file   dmpDefaultMPU6050.c
*      @brief
*
*/
#if defined MEMS_20609

#include "dmp3Driver.h"
#include "dmp3Default_20608D.h"
#include "invn_types.h"

#define CFG_PEDSTEP_DET                     (3363)
#define OUT_ACCL_DAT                        (2372)
#define CFG_FB_GAIN_GYRO_ON                 (1951)
#define CFG_OUT_GYRO                        (2397)
#define PED_STEP_COUNT2_DETECTED            (3369)
#define GYRO_FIFO_RATE                      (2383)
#define FSYNC_END                           (1334)
#define PREV_PQUAT                          (2424)
#define ACCEL_FIFO_RATE                     (2348)
#define PQUAT_FIFO_RATE                     (2313)
#define CFG_FIFO_INT                        (2525)
#define CFG_AUTH                            (1353)
#define CFG_OUT_FSYNC                       (1319)
#define FCFG_1                              (1420)
#define FCFG_3                              (1450)
#define FCFG_2                              (1424)
#define FCFG_7                              (1431)
#define CFG_OUT_3QUAT                       (2255)
#define OUT_3QUAT_DAT                       (2266)
#define CFG_PED_ENABLE                      (2535)
#define CFG_EXT_GYRO_BIAS                   (1539)
#define CFG_7                               (1887)
#define OUT_PQUAT_DAT                       (2337)
#define CFG_OUT_6QUAT                       (2291)
#define CFG_PED_INT                         (3352)
#define SMD_TP2                             (1827)
#define SMD_TP1                             (1804)
#define STEPDET_END                         (2241)
#define CFG_MOTION_BIAS                     (1888)
#define CFG_OUT_ACCL                        (2362)
#define CFG_OUT_STEPDET                     (2224)
#define OUT_6QUAT_DAT                       (2302)
#define QUAT6_FIFO_RATE                     (2277)
#define OUT_GYRO_DAT                        (2407)
#define CFG_OUT_PQUAT                       (2327)

#define D_EXT_GYRO_BIAS_X       (61 * 16)
#define D_EXT_GYRO_BIAS_Y       ((61 * 16) + 4)
#define D_EXT_GYRO_BIAS_Z       ((61 * 16) + 8)
#define GYRO_BIAS_X	D_EXT_GYRO_BIAS_X
#define GYRO_BIAS_Y	D_EXT_GYRO_BIAS_Y
#define GYRO_BIAS_Z	D_EXT_GYRO_BIAS_Z

#define D_EIS_ENABLE			(2 * 16 + 10)

#define D_SMD_ENABLE            (18 * 16)
#define D_SMD_MOT_THLD          (21 * 16 + 8)
#define SMD_VAR_TH	D_SMD_MOT_THLD

#define D_SMD_DELAY_THLD        (21 * 16 + 4)
#define D_SMD_DELAY2_THLD       (21 * 16 + 12)
#define D_SMD_EXE_STATE         (22 * 16)
#define D_SMD_DELAY_CNTR        (21 * 16)

#define D_VIB_DET_RATIO         (30 * 16 + 0)
#define D_VIB_MAG_TH            (31 * 16 + 0)
#define D_VIB_K                 (13 * 16 + 8)
#define D_VIB_K_1               (13 * 16 + 12)

#define D_ACC_SCALE             (29 * 16 + 0)
#define ACC_SCALE D_ACC_SCALE

#define D_AUTH_OUT              (992)
#define D_AUTH_IN               (996)
#define D_AUTH_A                (1000)
#define D_AUTH_B                (1004)
#define D_DMP_AUTH_INPUT		(70 * 16 + 4)
#define D_DMP_AUTH_OUTPUT		(70 * 16 + 0)

#define SC_AUT_OUTPUT_20608D		D_DMP_AUTH_INPUT
#define SC_AUT_INPUT_20608D		D_DMP_AUTH_OUTPUT

#define D_PEDSTD_BP_B           (768 + 0x1C)
#define D_PEDSTD_BP_A4          (768 + 0x40)
#define D_PEDSTD_BP_A3          (768 + 0x44)
#define D_PEDSTD_BP_A2          (768 + 0x48)
#define D_PEDSTD_BP_A1          (768 + 0x4C)
#define D_PEDSTD_SB             (768 + 0x28)
#define D_PEDSTD_SB_TIME        (768 + 0x2C)
#define D_PEDSTD_PEAKTHRSH      (768 + 0x98)
#define D_PEDSTD_TIML           (768 + 0x2A)
#define D_PEDSTD_TIMH           (768 + 0x2E)
#define D_PEDSTD_PEAK           (768 + 0X94)
#define D_PEDSTD_STEPCTR        (768 + 0x60)
#define PEDSTD_STEPCTR		D_PEDSTD_STEPCTR
#define D_PEDSTD_STEPCTR2       (58 * 16 + 8)
#define D_PEDSTD_TIMECTR        (964)
#define PEDSTD_TIMECTR		D_PEDSTD_TIMECTR
#define D_PEDSTD_DECI           (768 + 0xA0)
#define D_PEDSTD_SB2			(60 * 16 + 14)
#define D_STPDET_TIMESTAMP      (28 * 16 + 8)
#define STPDET_TIMESTAMP	D_STPDET_TIMESTAMP
#define D_PEDSTD_DRIVE_STATE    (58)
#define D_PEDSTEP_IND			(26*16 + 6)
#define PEDSTEP_IND				D_PEDSTEP_IND

#define D_HOST_NO_MOT           (976)
#define D_ACCEL_BIAS            (660)

/* Batch mode */
#define D_BM_BATCH_CNTR         (27*16+4)
#define D_BM_BATCH_THLD         (27*16+12)
#define BM_BATCH_CNTR		D_BM_BATCH_CNTR
#define BM_BATCH_THLD		D_BM_BATCH_THLD

#define D_BM_ENABLE             (28*16+6)
#define D_BM_NUMWORD_TOFILL     (28*16+4)

/* DMP running counter */
#define D_DMP_RUN_CNTR          (24*16)
#define DMPRATE_CNTR		D_DMP_RUN_CNTR

/* Sensor's ODR */
#define D_ODR_S2                (45*16+10)
#define D_ODR_S3                (45*16+14)
#define D_ODR_S4                (46*16+8)
#define D_ODR_S5                (46*16+12)

#define ODR_ACCEL			D_ODR_S4
#define ODR_GYRO			D_ODR_S5
#define ODR_QUAT6			D_ODR_S2
#define ODR_PQUAT6			D_ODR_S3

/* sensor output data rate counter */
#define D_ODR_CNTR_S2           (45*16+2)
#define D_ODR_CNTR_S3           (45*16+6)
#define D_ODR_CNTR_S4           (46*16)
#define D_ODR_CNTR_S5           (46*16+4)

#define ODR_CNTR_ACCEL				D_ODR_CNTR_S4
#define ODR_CNTR_GYRO				D_ODR_CNTR_S5
#define ODR_CNTR_QUAT6				D_ODR_CNTR_S2
#define ODR_CNTR_PQUAT6			D_ODR_CNTR_S3

/* DMP Fusion LP-Quat */
#define D_FS_LPQ0               (59*16)
#define D_FS_LPQ1               (59*16 + 4)
#define D_FS_LPQ2               (59*16 + 8)
#define D_FS_LPQ3               (59*16 + 12)

/* DMP Fusion (Accel+Gyro) Quat */
#define D_ACCEL_FB_GAIN			(6*16)
#define D_GYRO_SF				(6*16 + 8)
#define GYRO_SF		D_GYRO_SF
#define D_FS_Q0                 (12*16)
#define D_FS_Q1                 (12*16 + 4)
#define D_FS_Q2                 (12*16 + 8)
#define D_FS_Q3                 (12*16 + 12)

/* AK compass support */
#define D_CPASS_STATUS_CHK		(22*16 + 8)

#define ACCEL_SET				0x4000
#define GYRO_SET				0x2000
#define QUAT6_SET				0x0400
#define PQUAT6_SET			0x0200
#define PED_STEPDET_SET		0x0100
#define HEADER2_SET			0x0008
#define PED_STEPIND_SET		0x0007
#define FSYNC_HDR               0x7000

/* high byte of motion event control */
#define PEDOMETER_EN        0x4000
#define PEDOMETER_INT_EN    0x2000
#define TILT_INT_EN         0x1000
#define SMD_EN              0x0800
#define SECOND_SENSOR_AUTO  0x0400
#define ACCEL_CAL_EN        0x0200
#define GYRO_CAL_EN         0x0100
/* low byte of motion event control */
#define COMPASS_CAL_EN      0x0080
#define NINE_AXIS_EN        0x0040
#define S_HEALTH_EN         0x0020
#define FLIP_PICKUP_EN      0x0010
#define GEOMAG_RV_EN        0x0008
#define BRING_LOOK_SEE_EN   0x0004
#define BAC_ACCEL_ONLY_EN   0x0002

#define DMP_OFFSET               0x20
#define DMP_IMAGE_SIZE_20608D         (3535 + DMP_OFFSET)
#define DMP_START_ADDR_20608D    0x4B0
#define DMP_CODE_SIZE  DMP_IMAGE_SIZE_20608D-DMP_OFFSET

#if !defined USE_DMP_LOAD_SRAM
static const unsigned char dmp_memory[DMP_CODE_SIZE] =
{
#include "dmp3Default_20608D.txt"
};
#endif

//static unsigned short sStartAddress = 0x04b0;

/** Loads the dmp firmware for the 20609 part.
* @param[in] dmp_image_sram Load DMP3 image from SRAM.
*/
inv_error_t inv_load_firmware_20609(const unsigned char *dmp_image_sram)
{
    #if defined USE_DMP_LOAD_SRAM
    return inv_dmpdriver_mems_firmware_load(dmp_image_sram, DMP_CODE_SIZE, DMP_OFFSET);
    #else
    (void) *dmp_image_sram;
    return inv_dmpdriver_mems_firmware_load(dmp_memory, DMP_CODE_SIZE, DMP_OFFSET);
    #endif
}

/** Loads the dmp firmware for the 20609 part.
* @param[out] dmp_cnfg The config item
*/
void inv_get_dmp_start_address_20609(unsigned short *dmp_cnfg)
{
    *dmp_cnfg = DMP_START_ADDR_20608D;
}

inv_error_t dmp_reset_odr_counters_20609()
{
    inv_error_t result;
    unsigned char data[4] = {0x00, 0x00, 0x00, 0x00};
    result = inv_dmpdriver_write_mems(ODR_CNTR_ACCEL, 4, data);
    result |= inv_dmpdriver_write_mems(ODR_CNTR_GYRO, 4, data);
    result |= inv_dmpdriver_write_mems(ODR_CNTR_QUAT6, 4, data);
    result |= inv_dmpdriver_write_mems(ODR_CNTR_PQUAT6, 4, data);
    return result;
}

/**
* Sets sensor ODR.
* @param[in] sensor		sensor number based on INV_SENSORS
*	enum INV_SENSORS {
*		INV_SENSOR_ACCEL = 0,
*		INV_SENSOR_GYRO,
*		INV_SENSOR_SIXQ,
*		INV_SENSOR_PEDQ
*	};
* @param[in] divider	desired ODR = base engine rate/(divider + 1)
*/
inv_error_t dmp_set_sensor_rate_20609(int invSensor, short divider)
{
    inv_error_t result;
    unsigned char big8[2] = {0};
    int odr_addr;

    switch (invSensor)
    {
        case INV_SENSOR_ACCEL:
            odr_addr = ODR_ACCEL;
            break;

        case INV_SENSOR_GYRO:
            odr_addr = ODR_GYRO;
            break;

        case INV_SENSOR_SIXQ:
            odr_addr = ODR_QUAT6;
            break;

        case INV_SENSOR_PEDQ:
            odr_addr = ODR_PQUAT6;
            break;
    }

    result = inv_dmpdriver_write_mems(odr_addr, 2, inv_dmpdriver_int16_to_big8(divider, big8));

    if (result)
        return result;

    return INV_SUCCESS;
}

/**
* Gets pedometer step count.
* @param[in] steps
* @param[out] steps
*/
inv_error_t dmp_get_pedometer_num_of_steps_20609(unsigned long *steps)
{
    inv_error_t result;
    unsigned char big8[4] = {0};

    result = inv_dmpdriver_read_mems(PEDSTD_STEPCTR, 4, big8);

    if (result)
        return result;

    *steps = (big8[0] * (1L << 24)) + (big8[1] * (1L << 16)) + (big8[2] * 256) + big8[3];

    return INV_SUCCESS;
}

int inv_enable_gyro_cal(int en)
{
    unsigned char reg[3] = {0xc2, 0xc5, 0xc7};
    int result;

    if (!en)
    {
        reg[0] = 0xf1;
        reg[1] = 0xf1;
        reg[2] = 0xf1;
    }


    result = inv_dmpdriver_write_mems(CFG_EXT_GYRO_BIAS, 3, &reg[0]);

    return result;
}

int inv_enable_pedometer_interrupt(int en)
{
    unsigned char reg[3];

    if (en)
    {
        reg[0] = 0xf4;
        reg[1] = 0x44;
        reg[2] = 0xf1;

    }
    else
    {
        reg[0] = 0xf1;
        reg[1] = 0xf1;
        reg[2] = 0xf1;
    }

    return inv_dmpdriver_write_mems(CFG_PED_INT, 3, reg);
}

int inv_enable_pedometer(int en)
{
    unsigned char d[1];

    if (en)
        d[0] = 0xf1;
    else
        d[0] = 0xff;

    return inv_dmpdriver_write_mems(CFG_PED_ENABLE, 1, d);
}

int inv_send_stepdet_data(int enable)
{
    unsigned char reg[3] = {0xa3, 0xa3, 0xa3};
    int result;

    /* turning off step detect jumps to STEPDET_END */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (STEPDET_END >> 8) & 0xff;
        reg[2] = STEPDET_END & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_STEPDET, 3, &reg[0]);

    return result;
}


int inv_add_step_indicator(int enable)
{
    unsigned char reg[3] = {0xf3, 0xf3, 0xf3};
    int result;

    /* turning off step indicator jumps to PED_STEP_COUNT2_DETECTED */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (PED_STEP_COUNT2_DETECTED >> 8) & 0xff;
        reg[2] = PED_STEP_COUNT2_DETECTED & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_PEDSTEP_DET, 3, reg);

    return result;
}

int inv_enable_smd(int en)
{
    unsigned char d[1];

    if (en)
        d[0] = 1;
    else
        d[0] = 0;

    return inv_dmpdriver_write_mems(D_SMD_ENABLE, 1, d);
}


int inv_send_gyro_data(int enable)
{
    unsigned char reg[3] = {0xa3, 0xa3, 0xa3};
    int result;

    /* turning off gyro jumps to PREV_PQUAT */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (PREV_PQUAT >> 8) & 0xff;
        reg[2] = PREV_PQUAT & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_GYRO, 3, reg);

    return result;
}

static int inv_out_fsync(int enable)
{
    unsigned char reg[3] = {0xf3, 0xf3, 0xf3};
    int result;

    /* turning off fsync jumps to FSYNC_END */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (FSYNC_END >> 8) & 0xff;
        reg[2] = FSYNC_END & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_FSYNC, 3, reg);

    return result;
}

static int inv_enable_eis(int enable)
{
    unsigned char reg[2] = {0};
    int result;

    if (enable)
        reg[1] = 0x1;

    result = inv_dmpdriver_write_mems(D_EIS_ENABLE, 2, reg);

    return result;
}

int inv_send_accel_data(int enable)
{
    unsigned char reg[3] = {0xa3, 0xa3, 0xa3};
    int result;

    /* turning off accel jumps to GYRO_FIFO_RATE */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (GYRO_FIFO_RATE >> 8) & 0xff;
        reg[2] = GYRO_FIFO_RATE & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_ACCL, 3, reg);

    return result;
}

int inv_send_six_q_data(int enable)
{
    unsigned char reg[3] = {0xa3, 0xa3, 0xa3};
    int result;

    /* turning off 6-axis jumps to PQUAT_FIFO_RATE */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (PQUAT_FIFO_RATE >> 8) & 0xff;
        reg[2] = PQUAT_FIFO_RATE & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_6QUAT, 3, reg);

    return result;
}

int inv_send_ped_q_data(int enable)
{
    unsigned char reg[3] = {0xa3, 0xa3, 0xa3};
    int result;

    /* turning off pquat jumps to ACCEL_FIFO_RATE */
    if (!enable)
    {
        reg[0] = 0xf4;
        reg[1] = (ACCEL_FIFO_RATE >> 8) & 0xff;
        reg[2] = ACCEL_FIFO_RATE & 0xff;
    }

    result = inv_dmpdriver_write_mems(CFG_OUT_PQUAT, 3, reg);

    return result;
}

int inv_enable_batch(int on)
{
    unsigned char d[] = {0};
    int result;

    d[0] = on;
    result = inv_dmpdriver_write_mems(D_BM_ENABLE, 1, d);

    return result;
}


int dmp_set_dataout_control1_20609(uint16_t cntl1)
{
    int result = 0;

    if (cntl1 & ACCEL_SET)
        result = inv_send_accel_data(1);
    else
        result = inv_send_accel_data(0);

    if (cntl1 & GYRO_SET)
        result |= inv_send_gyro_data(1);
    else
        result |= inv_send_gyro_data(0);

    if (cntl1 & QUAT6_SET)
        result |= inv_send_six_q_data(1);
    else
        result |= inv_send_six_q_data(0);

    if (cntl1 & PQUAT6_SET)
        result |= inv_send_ped_q_data(1);
    else
        result |= inv_send_ped_q_data(0);

    if ((cntl1 & PED_STEPDET_SET))
    {
        result |= inv_enable_pedometer(1);
        result |= inv_enable_pedometer_interrupt(1);
        result |= inv_send_stepdet_data(1);
    }
    else
    {
        result |= inv_enable_pedometer(0);
        result |= inv_enable_pedometer_interrupt(0);
        result |= inv_send_stepdet_data(0);
    }

    return result;
}

int dmp_set_dataout_control2_20609(uint16_t cntl2)
{
    int result = 0;
    int en;

    if (cntl2 & BATCH_MODE_EN)
        en = 1;
    else
        en = 0;

    result = inv_enable_batch(en);

    if (result)
        return result;

    if (cntl2 & FSYNC_SET)
        en = 1;
    else
        en = 0;

    result = inv_enable_eis(en);

    if (result)
        return result;

    result = inv_out_fsync(en);

    if (result)
        return result;

    return result;
}

int dmp_set_motion_interrupt_control_20609(uint16_t motion_event_cntl)
{
    int result = 0;

    if (motion_event_cntl & PEDOMETER_EN)
        result = inv_enable_pedometer(1);
    else
        result = inv_enable_pedometer(0);

    /*if (motion_event_cntl & PEDOMETER_INT_EN)
    	result = inv_enable_pedometer_interrupt(1);
    else
    	result = inv_enable_pedometer_interrupt(0);*/

    if (motion_event_cntl & SMD_EN)
        result = inv_enable_smd(1);
    else
        result = inv_enable_smd(0);

    if (motion_event_cntl & GYRO_CAL_EN)
        result = inv_enable_gyro_cal(1);
    else
        result = inv_enable_gyro_cal(0);

    return result;
}

/**
* Sets bias in DMP.
* @param[in] bias
*	array is set as follows:
*	[0] accel_x (N/A)
*	[1] accel_y (N/A)
*	[2] accel_z (N/A)
*	[3] gyro_x
*	[4] gyro_y
*	[5] gyro_z
*	[6] compass_x (N/A)
*	[7] compass_y (N/A)
*	[8] compass_z (N/A)
*/
inv_error_t dmp_set_bias_20609(int *bias)
{
    inv_error_t result;
    unsigned char big8[4] = {0};

    result = inv_dmpdriver_write_mems(GYRO_BIAS_X, 4, inv_dmpdriver_int32_to_big8(bias[3], big8));
    result += inv_dmpdriver_write_mems(GYRO_BIAS_Y, 4, inv_dmpdriver_int32_to_big8(bias[4], big8));
    result += inv_dmpdriver_write_mems(GYRO_BIAS_Z, 4, inv_dmpdriver_int32_to_big8(bias[5], big8));

    if (result)
        return result;

    return INV_SUCCESS;
}

/**
* Gets bias from DMP.
* @param[in] bias
* @param[out] bias
*	array is set as follows:
*	[0] accel_x (N/A)
*	[1] accel_y (N/A)
*	[2] accel_z (N/A)
*	[3] gyro_x
*	[4] gyro_y
*	[5] gyro_z
*	[6] compass_x (N/A)
*	[7] compass_y (N/A)
*	[8] compass_z (N/A)
*/
inv_error_t dmp_get_bias_20609(int *bias)
{
    inv_error_t result;
    unsigned char big8[4] = {0};

    result = inv_dmpdriver_read_mems(GYRO_BIAS_X, 4, big8);
    bias[3] = inv_dmpdriver_big8_to_int32(big8);
    result += inv_dmpdriver_read_mems(GYRO_BIAS_Y, 4, big8);
    bias[4] = inv_dmpdriver_big8_to_int32(big8);
    result += inv_dmpdriver_read_mems(GYRO_BIAS_Z, 4, big8);
    bias[5] = inv_dmpdriver_big8_to_int32(big8);

    if (result)
        return result;

    return INV_SUCCESS;
}

#endif


